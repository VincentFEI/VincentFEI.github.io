<!doctype html>
<!-- This site was created with Hugo Blox. https://hugoblox.com -->
<!-- Last Published: December 7, 2024 --><html lang="en-us" dir="ltr"
      data-wc-theme-default="system">
  
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="generator" content="Hugo Blox Builder 0.2.0" />

  
  












  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Pengfei Zhang" />

  
  
  
    
  
  <meta name="description" content="The highly-customizable Hugo Academic theme powered by Hugo Blox Builder. Easily create your personal academic website." />

  
  <link rel="alternate" hreflang="en-us" href="https://zhangpengfei.com/project/" />

  
  
  
  
    
    <link rel="stylesheet" href="/css/themes/emerald.min.css" />
  

  
  
    
    <link href="/dist/wc.min.css" rel="stylesheet" />
  

  
  
  

  

  <script>
     
    window.hbb = {
       defaultTheme: document.documentElement.dataset.wcThemeDefault,
       setDarkTheme: () => {
        document.documentElement.classList.add("dark");
        document.documentElement.style.colorScheme = "dark";
      },
       setLightTheme: () => {
        document.documentElement.classList.remove("dark");
        document.documentElement.style.colorScheme = "light";
      }
    }

    console.debug(`Default Hugo Blox Builder theme is ${window.hbb.defaultTheme}`);

    if ("wc-color-theme" in localStorage) {
      localStorage.getItem("wc-color-theme") === "dark" ? window.hbb.setDarkTheme() : window.hbb.setLightTheme();
    } else {
      window.hbb.defaultTheme === "dark" ? window.hbb.setDarkTheme() : window.hbb.setLightTheme();
      if (window.hbb.defaultTheme === "system") {
        window.matchMedia("(prefers-color-scheme: dark)").matches ? window.hbb.setDarkTheme() : window.hbb.setLightTheme();
      }
    }
  </script>

  <script>
    
    document.addEventListener('DOMContentLoaded', function () {
      
      let checkboxes = document.querySelectorAll('li input[type=\'checkbox\'][disabled]');
      checkboxes.forEach(e => {
        e.parentElement.parentElement.classList.add('task-list');
      });

      
      const liNodes = document.querySelectorAll('.task-list li');
      liNodes.forEach(nodes => {
        let textNodes = Array.from(nodes.childNodes).filter(node => node.nodeType === 3 && node.textContent.trim().length > 1);
        if (textNodes.length > 0) {
          const span = document.createElement('label');
          textNodes[0].after(span);  
          span.appendChild(nodes.querySelector('input[type=\'checkbox\']'));
          span.appendChild(textNodes[0]);
        }
      });
    });
  </script>

  
  
  




































  
  
    <link rel="alternate" href="/project/index.xml" type="application/rss+xml" title="ZhangPengfei CV Site" />
  

  
  <link rel="icon" type="image/png" href="/media/icon_hu3247630877640252165.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu4166356570829923896.png" />

  <link rel="canonical" href="https://zhangpengfei.com/project/" />

  
  
  
  
  
  
  
  
    
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary" />
  
    <meta property="twitter:site" content="@GetResearchDev" />
    <meta property="twitter:creator" content="@GetResearchDev" />
  
  <meta property="og:site_name" content="ZhangPengfei CV Site" />
  <meta property="og:url" content="https://zhangpengfei.com/project/" />
  <meta property="og:title" content="Projects | ZhangPengfei CV Site" />
  <meta property="og:description" content="The highly-customizable Hugo Academic theme powered by Hugo Blox Builder. Easily create your personal academic website." /><meta property="og:image" content="https://zhangpengfei.com/media/icon_hu7729264130191091259.png" />
    <meta property="twitter:image" content="https://zhangpengfei.com/media/icon_hu7729264130191091259.png" /><meta property="og:locale" content="en-us" />
  
    
      <meta property="og:updated_time" content="2024-05-19T00:00:00&#43;00:00" />
    
  

  




  <title>Projects | ZhangPengfei CV Site</title>

  
  
  
  
  
    
    
  
  
  <style>
    @font-face {
      font-family: 'Inter var';
      font-style: normal;
      font-weight: 100 900;
      font-display: swap;
      src: url(/dist/font/Inter.var.woff2) format(woff2);
    }
  </style>

  

  
  


  
    
      
      
        
        
          
        
          
        
          
        
          
        
          
        
        
        
      
    
      
      
    
  
    
      
      
        
        
          
        
          
        
          
        
          
        
          
        
        
        
      
    
      
      
        
        
          
        
          
        
          
        
          
        
          
        
        
        
      
    
  
  
  
  
    
      
      
        
        
          
        
          
        
          
        
          
        
          
        
        
        
      
    
  
  
  
  
  
  
  
  
  
  
  
    
      
      
        
        
          
        
          
        
          
        
          
        
          
        
        
        
      
    
  
  
  
    
      
      
        
        
          
        
          
        
          
        
          
        
          
        
        
        
      
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  














  
  
  <link type="text/css" rel="stylesheet" href="/dist/lib/katex/katex.min.505d5f829022bb7b4f24dfee0aa1141cd7bba67afe411d1240335f820960b5c3.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr&#43;QR0SQDNfgglgtcM=" />
  
  
  <script defer src="/dist/lib/katex/katex.min.dc84b296ec3e884de093158f760fd9d45b6c7abe58b5381557f4e138f46a58ae.js" integrity="sha256-3ISyluw&#43;iE3gkxWPdg/Z1Ftser5YtTgVV/ThOPRqWK4="></script>
  
  
  
  
  <script defer src="/js/katex-renderer.6579ec9683211cfb952064aedf3a3baea5eeb17a061775b32b70917474637c80.js" integrity="sha256-ZXnsloMhHPuVIGSu3zo7rqXusXoGF3WzK3CRdHRjfIA="></script>
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  






  
  
  
  
  
  
  
  <script
    defer
    src="/js/hugo-blox-en.min.e5fa931947cac2d947732ea37a770aae2b5bd4a50b6048060cd129b46159a06d.js"
    integrity="sha256-5fqTGUfKwtlHcy6jencKritb1KULYEgGDNEptGFZoG0="
  ></script>

  
  








  
    
      
      <script async defer src="https://buttons.github.io/buttons.js"></script>

      
    
  




</head>

  <body class="dark:bg-hb-dark dark:text-white page-wrapper" id="top">
    <div id="page-bg"></div>
    <div class="page-header sticky top-0 z-30">
      
      
      
        
        
        
          <header id="site-header" class="header">
  <nav class="navbar px-3 flex justify-left">
    <div class="order-0 h-100">
      
      <a class="navbar-brand" href="/" title="ZhangPengfei CV Site">
        Pengfei Zhang
      </a>
    </div>
    
    <input id="nav-toggle" type="checkbox" class="hidden" />
    <label
      for="nav-toggle"
      class="order-3 cursor-pointer flex items-center lg:hidden text-dark dark:text-white lg:order-1">
      <svg id="show-button" class="h-6 fill-current block" viewBox="0 0 20 20">
        <title>Open Menu</title>
        <path d="M0 3h20v2H0V3z m0 6h20v2H0V9z m0 6h20v2H0V0z"></path>
      </svg>
      <svg id="hide-button" class="h-6 fill-current hidden" viewBox="0 0 20 20">
        <title>Close Menu</title>
        <polygon
          points="11 9 22 9 22 11 11 11 11 22 9 22 9 11 -2 11 -2 9 9 9 9 -2 11 -2"
          transform="rotate(45 10 10)"></polygon>
      </svg>
    </label>
    

    
    
    <ul
      id="nav-menu"
      class="navbar-nav order-3 hidden lg:flex w-full pb-6 lg:order-1 lg:w-auto lg:space-x-2 lg:pb-0 xl:space-x-8 justify-left
      ">
      
      
      
      
      
      
      <li class="nav-item">
        <a
          class="nav-link "
          
          href="/"
        >Home</a
        >
      </li>
      
      
      
      
      
      
      <li class="nav-item">
        <a
          class="nav-link "
          
          href="/experience"
        >Experience</a
        >
      </li>
      
      
      
      
      
      
      <li class="nav-item">
        <a
          class="nav-link "
          
          href="/publication"
        >Papers</a
        >
      </li>
      
      
      
      
      
      
      <li class="nav-item">
        <a
          class="nav-link "
          
          href="/project"
        >Projects</a
        >
      </li>
      
      
      
    </ul>

    <div class="order-1 ml-auto flex items-center md:order-2 lg:ml-0">

      
      
      

      
      

      
      

      
      
    </div>
  </nav>
</header>



        
      
    </div>
    <div class="page-body ">
      

  
  
    








  

  

  

  

  






























  





























<section id="section-collection" class="relative hbb-section blox-collection  "  >
 <div class="home-section-bg " >
   
 </div>
  

  

    











  









  
  
  
  
  






















  





<div class="flex flex-col items-center max-w-prose mx-auto gap-3 justify-center">

  <div class="mb-6 text-3xl font-bold text-gray-900 dark:text-white">
    Projects
  </div>

  
</div>


<div class="flex flex-col items-center">

  
  


<div class="container px-8 mx-auto xl:px-5 py-5 lg:py-8 max-w-screen-lg ">
  <div class="grid gap-10 md:grid-cols-1 lg:gap-10">


  
    









<div class="group cursor-pointer">

  
  
  
    
  
  
  <div class="overflow-hidden rounded-md bg-gray-100 transition-all hover:scale-105 dark:bg-gray-800">

    <a
      class="relative block aspect-video"
      href="/project/spatial_temporal_decider/" >

      <img alt="Spatial Temporal Decider"
           class="object-contain transition-all"
           data-nimg="fill"
           decoding="async"
           fetchpriority="high" height="372" loading="lazy" src="/project/spatial_temporal_decider/featured_hu130324222603191903.webp"
           style="position: absolute; height: 100%; width: 100%; inset: 0px; color: transparent;"
           width="796"></a>
  </div>
  
  <div class="">
    <div class="">
      <div class="flex gap-3">
        
        <a href="/tags/autonomous-driving/"><span
          class="inline-block text-xs font-medium tracking-wider uppercase mt-5 text-primary-700 dark:text-primary-300">Autonomous Driving</span></a>
        
      </div>
      
      <h2 class="text-lg font-semibold leading-snug tracking-tight mt-2 dark:text-white"><a
        href="/project/spatial_temporal_decider/" ><span
        class="bg-gradient-to-r from-primary-200 to-primary-100 bg-[length:0px_10px] bg-left-bottom bg-no-repeat transition-[background-size] duration-500 hover:bg-[length:100%_3px] group-hover:bg-[length:100%_10px] dark:from-primary-800 dark:to-primary-900">Spatial Temporal Decider
          </span></a>
      </h2>
      
      <div class="grow"><p class="mt-2 line-clamp-3 text-sm text-gray-500 dark:text-gray-400"><a
        href="/project/spatial_temporal_decider/" >
        1 Background In traditional autonomous driving decision-making and planning frameworks, a lateral-longitudinal hierarchical architecture is often employed. However, since lateral and longitudinal decisions are made independently within this framework, their performance is often suboptimal in scenarios requiring close coordination between path and speed.</a></p>
      </div>
      <div class="flex-none">
        <div class="mt-3 flex items-center space-x-3 text-gray-500 dark:text-gray-400 cursor-default">
          
          
          <time class="truncate text-sm" datetime="2024-07-01">Jul 1, 2024</time>
        </div>
      </div>

    </div>
  </div>
</div>

  
    









<div class="group cursor-pointer">

  
  
  
    
  
  
  <div class="overflow-hidden rounded-md bg-gray-100 transition-all hover:scale-105 dark:bg-gray-800">

    <a
      class="relative block aspect-video"
      href="/project/path_planner/" >

      <img alt="Cartesian Path Planner"
           class="object-contain transition-all"
           data-nimg="fill"
           decoding="async"
           fetchpriority="high" height="383" loading="lazy" src="/project/path_planner/featured_hu10716822614946557958.webp"
           style="position: absolute; height: 100%; width: 100%; inset: 0px; color: transparent;"
           width="843"></a>
  </div>
  
  <div class="">
    <div class="">
      <div class="flex gap-3">
        
        <a href="/tags/autonomous-driving/"><span
          class="inline-block text-xs font-medium tracking-wider uppercase mt-5 text-primary-700 dark:text-primary-300">Autonomous Driving</span></a>
        
      </div>
      
      <h2 class="text-lg font-semibold leading-snug tracking-tight mt-2 dark:text-white"><a
        href="/project/path_planner/" ><span
        class="bg-gradient-to-r from-primary-200 to-primary-100 bg-[length:0px_10px] bg-left-bottom bg-no-repeat transition-[background-size] duration-500 hover:bg-[length:100%_3px] group-hover:bg-[length:100%_10px] dark:from-primary-800 dark:to-primary-900">Cartesian Path Planner
          </span></a>
      </h2>
      
      <div class="grow"><p class="mt-2 line-clamp-3 text-sm text-gray-500 dark:text-gray-400"><a
        href="/project/path_planner/" >
        1 Background Traditional path planning methods based on the Frenet coordinate system have advantages such as simple problem formulation and fast solving speed. However, they also suffer from significant drawbacks, including a heavy reliance on the reference line, overly complex curvature constraints, difficulty in evaluating ride comfort, and highly inaccurate modeling of collision constraints.
To address these issues, we propose a path planning approach in the Cartesian coordinate system. The Cartesian-based method offers advantages such as the ability to incorporate precise vehicle kinematic constraints, curvature constraints, and collision constraints, making it easier to ensure the feasibility and safety of the path. However, path planning in the Cartesian coordinate system also faces several challenges. For instance, kinematic constraints become nonlinear equality constraints, collision constraints shift from convex to non-convex, and the reference line cost transitions from a simple quadratic function to a complex nonlinear form. These characteristics result in the optimization problem having numerous local minima, increasing reliance on the initial solution and imposing higher demands on the convergence and solving speed of the optimization algorithm.
2 Technical Details 2.1 Path Representation Common path representations in autonomous driving include Bézier curves, B-spline curves, spiral curves, and vehicle kinematic models. In our approach, we adopt the kinematic model, using $\dot\kappa$ as the control input and $X$, $Y$, $\theta$, and $\kappa$ as the system states. Compared to other methods, this path representation offers significant flexibility and allows for straightforward constraints on $\kappa$ and $\dot\kappa$. However, it has a notable drawback: ensuring path smoothness is challenging, as it is influenced by other cost functions and constraints.
2.2 Collision Constraint Modeling This involves two aspects of selection: the representation of the ego vehicle and the representation of the environment. These two factors also influence each other.
For the representation of the ego vehicle, it can be modeled as a convex polygon, typically a rectangle, or as a union of multiple enclosing circles. Generally, the convex polygon representation is more accurate than the enclosing circle method. However, calculating the distance between a convex polygon and obstacles is significantly more complex than calculating the distance between enclosing circles and obstacles.
For the representation of the environment, there are three main approaches:
Direct Representation: Obstacles are modeled as convex hulls, such as convex polygons, spheres, or ellipsoids. Drivable Corridor Representation: Drivable regions are represented as a union of convex sets, such as convex polygons or spheres. Distance Field Representation: A global distance function is constructed, where the input is a coordinate, and the output is the distance from this coordinate to the nearest obstacle. The typical representation is Euclidean Signed Distance Field (ESDF). Each of these methods has its advantages and disadvantages.
The first approach requires few assumptions, preserving the original feasible space to the greatest extent. However, it involves complex distance calculations and is inefficient when there are many obstacles. The second approach confines the solution within a drivable space. Each segment of the solution corresponds to a convex constraint, greatly simplifying the constraint of the problem. However, constructing the convex corridor is time-consuming, often loses significant drivable space, and the allocation of appropriate convex constraints to each segment heavily impacts the final solution. The third approach is highly efficient, with the time complexity for distance and gradient calculations based on the distance field being O(1). However, building the distance field is time-consuming, and its resolution greatly affects the resulting path. Ultimately, we opted for the enclosing circle representation for the ego vehicle, sacrificing some accuracy to achieve lower computational complexity. For the environment representation, we experimented with both the drivable corridor and Euclidean distance field approaches and chose the Euclidean distance field method. This section provides a high-level overview of the technical choices. In practical implementation, regardless of the chosen representation method, numerous engineering techniques and algorithmic improvements are required to achieve an better result.
2.3 Reference Line Cost Modeling Before introducing the specific modeling approach, it is essential to clarify the complexity of reference line costs. In the Frenet coordinate system, the reference line cost is a simple quadratic function:
$$\min_L \frac{1}{2} w_l L^2$$
However, in the Cartesian coordinate system, this cost function becomes much more complex. In fact, the reference line cost can be generalized to achieve the same optimization goals as in the Frenet system, which is essentially a cost designed for the $(S, L)$ variables. For instance, the reference line cost in the Cartesian system can be expressed as:
$$\min_{X, Y} \frac{1}{2} w_l L(X, Y)^2$$
where $L(X,Y)$ is a Frenet projection function of $X$ and $Y$.
Generally, projecting Cartesian coordinates $(X, Y)$ into Frenet coordinates $(S, L)$ involves two main steps. The first step determines the corresponding $S$ by identifying the nearest point on the reference line to $(X, Y)$. The second step computes $L$ based on the normal vector of the reference line at $S$.
For the first step, the common engineering approach is to traverse all points on the reference line to find the nearest one and use its $S$ coordinate as the projection result. For the second step, assume the reference line point at $S$ has coordinates $[X(S), Y(S)]$ and a normal vector $[N_X(S), N_Y(S)]$. Then, $L(X, Y)$ can be calculated as:
$$L(X, Y) = \left[X - X(S), Y - Y(S)\right] \cdot \left[\begin{matrix}N_X(S)\\ N_Y(S)\end{matrix}\right]$$Based on the above, modeling the reference line cost, as well as other Frenet optimization objectives, primarily involves efficiently determining the $(S, L)$ values corresponding to $(X, Y)$ and quickly computing the gradients $\frac{dS}{dX}, \frac{dS}{dY}, \frac{dL}{dX}, \frac{dL}{dY}$.
Two feasible methods address this objective:
Fixed Nearest Point Approach:
For each path point in the initial solution, search for the nearest point and fix its $S$ value for the subsequent optimization process. The advantage of this approach is that $\frac{dS}{dX} = 0$ and $\frac{dS}{dY} = 0$, simplifying the reference line cost. However, the drawback is that when there is a significant difference between the initial solution and the optimal solution, the initially assigned $S$ value may deviate greatly from the accurate $S$, leading to a final solution that does not align with the intended cost design.
Precomputed SLMap Approach:
Before optimization, precompute an SLMap, a function that maps $(X, Y)$ inputs to $(S, L)$ outputs. The advantage of this method is that it avoids any prior assumptions and allows for very fast queries. However, constructing this map is time-intensive. Additionally, for the reference line cost specifically, it is sufficient to compute the projection relationship between $L$ and $(X, Y)$. This can be replaced by using a Euclidean distance field constructed based on the reference line.
2.4 Optimization Algorithm Path optimization in the Cartesian coordinate system can be formulated as a special type of constrained optimization problem, characterized primarily by chained equality constraints. Depending on the path representation, these constraints manifest as different kinematic or curve continuity constraints. In essence, this is treated as an optimal control problem.
There are two main approaches to solving optimal control problems: collocation methods and shooting methods.
Collocation Method:
Collocation methods optimize both state variables and control variables simultaneously, treating kinematic constraints as general equality constraints. This approach is similar to how general constrained optimization problems are handled. Collocation methods are more numerically stable, less sensitive to the initial solution, and more easily to converge. However, they may not strictly satisfy kinematic constraints, involve more optimization variables, and have higher computational complexity.
Shooting Method:
Shooting methods optimize only the control variables, while the state variables are propagated through the kinematic constraints. This ensures that kinematic constraints are strictly satisfied. Compared to collocation methods, shooting methods involve fewer optimization variables but are more sensitive to the initial solution and are prone to divergence.
The Iterative Linear Quadratic Regulator (ILQR) algorithm is a classic example of a shooting method and is one of the most widely used optimization algorithms in the autonomous driving. Its advantages include the ability to strictly satisfy kinematic constraints and the use of dynamic programming to decompose a large-scale optimization problem into many smaller problems, thereby reducing complexity. However, its drawbacks include susceptibility to divergence, poor stability, and a lack of mechanisms to handle constraints other than kinematic ones.
The ILQR algorithm was likely first popularized at Waymo, leading many domestic companies to adopt it. However, it might not be the most suitable optimization algorithm in all scenarios. In practical engineering implementations, applying the ILQR algorithm effectively often requires additional mechanisms for constraint handling (e.g., penalty functions or augmented Lagrangian methods), multiple shooting techniques, and trust region methods.
3 Engineering Techniques 3.1 Problem Modeling Selection of Enclosing Circle Position, Number, and Radius:
The position, radius, and number of enclosing circles need to balance accuracy and efficiency. For path planning, the enclosing circles should not cover the entire vehicle body, but rather the entire path. From this perspective, we can reduce both the radius and the number of enclosing circles.
Polyline Boundary Smoothing Method:
For path planning, assuming that left and right boundaries are given and both are represented by piecewise polylines, with the ego vehicle’s shape represented by enclosing circles, there is a need to frequently check if a circle intersects a polyline segment, or the distance between the circle and the polyline. This can be computationally expensive. One alternative approach is to assume a circle rolls from the start point of the polyline to the endpoint. The trajectory traced by the circle’s center will form a new boundary. Subsequently, we only need to ensure that the center of the ego vehicle’s enclosing circle remains inside this new boundary.
Convex Corridor Construction Method:
Constructing a convex corridor in path planning needs to be efficient while avoiding the loss of feasible space. For autonomous driving, the reference line can serve as a heuristic, where points are taken along the reference line at intervals and used as seeds to build the convex space.
Allocation and Switching of Convex Space Constraints:
It is possible that the convex space constraint for a given path point may differ between consecutive iterations. How can we switch constraints without affecting the convergence? The answer is that constraint switching should only occur from a larger violation of the constraint to a smaller one. For example, when switching convex space constraints, we need to evaluate the distance from the path point to the convex hull and only allow switching from a larger distance to a smaller one, but not the reverse.
ESDF Smoothing Method:
In path planning, if the ESDF is used to evaluate the distance to obstacles, and the ego vehicle’s shape is represented by enclosing circles, we observe that directly constructing the ESDF from the actual obstacle boundaries leads to many local minima. This issue can be alleviated by first expanding the obstacles according to the radius of the ego vehicle’s enclosing circle and then constructing the ESDF.
Frenet Distance Field Construction and Update Method:
Before constructing the Frenet distance field, simplify the reference line by reducing the original reference line to a piecewise polyline within a given error range. Then, calculate the distance field based on this polyline. The distance field is stored in blocks and is progressively updated as the vehicle moves forward.
3.2 Optimization Solving Penalty Function Selection:
Exponential and log-based obstacle functions grow too quickly and can cause divergence during the iteration process. A polynomial-based obstacle function is a better choice, provided it is twice differentiable near zero.
Selection of Penalty Coefficients in Penalty Functions:
The penalty coefficient should not be set too large at the outset. It is better to gradually increase the penalty, which helps to avoid local minima when the initial solution quality is poor.
Trust Region Mechanism:
ILQR is a shooting-based algorithm, where small changes in control inputs can lead to large trajectory deviations due to the cumulative effects of the kinematic model. This can lead to instability in the iteration process or cause iterations to stagnate (because the step size must be very small). Therefore, it is necessary to constrain the range of control input changes. This can be done by adding regularization terms to the cost function or by directly enforcing constraints.</a></p>
      </div>
      <div class="flex-none">
        <div class="mt-3 flex items-center space-x-3 text-gray-500 dark:text-gray-400 cursor-default">
          
          
          <time class="truncate text-sm" datetime="2023-07-01">Jul 1, 2023</time>
        </div>
      </div>

    </div>
  </div>
</div>

  
    









<div class="group cursor-pointer">

  
  
  
    
  
  
  <div class="overflow-hidden rounded-md bg-gray-100 transition-all hover:scale-105 dark:bg-gray-800">

    <a
      class="relative block aspect-video"
      href="/project/robotic_remora/" >

      <img alt="Bionic Robotic Remora"
           class="object-contain transition-all"
           data-nimg="fill"
           decoding="async"
           fetchpriority="high" height="540" loading="lazy" src="/project/robotic_remora/featured_hu14078486800753234543.webp"
           style="position: absolute; height: 100%; width: 100%; inset: 0px; color: transparent;"
           width="869"></a>
  </div>
  
  <div class="">
    <div class="">
      <div class="flex gap-3">
        
        <a href="/tags/robotic/"><span
          class="inline-block text-xs font-medium tracking-wider uppercase mt-5 text-primary-700 dark:text-primary-300">Robotic</span></a>
        
      </div>
      
      <h2 class="text-lg font-semibold leading-snug tracking-tight mt-2 dark:text-white"><a
        href="/project/robotic_remora/" ><span
        class="bg-gradient-to-r from-primary-200 to-primary-100 bg-[length:0px_10px] bg-left-bottom bg-no-repeat transition-[background-size] duration-500 hover:bg-[length:100%_3px] group-hover:bg-[length:100%_10px] dark:from-primary-800 dark:to-primary-900">Bionic Robotic Remora
          </span></a>
      </h2>
      
      <div class="grow"><p class="mt-2 line-clamp-3 text-sm text-gray-500 dark:text-gray-400"><a
        href="/project/robotic_remora/" >
        1 Background Biomimetic robotic fish, by imitating the shape and oscillatory propulsion mechanism of real fish, exhibit numerous advantages such as high mobility, minimal environmental disturbance, and strong concealment, making them a new type of underwater robot with significant research value and broad application prospects. However, under current energy technology conditions, the energy that robotic fish can carry is limited, making it difficult to perform long-distance, long-duration, and large-scale marine tasks. Therefore, enhancing the endurance of robotic fish has become a critical issue that needs to be addressed.
In nature, the hitch-hiking behavior of remora fish provides inspiration for solving this problem. Remora fish attach themselves to larger fish or marine animals using their dorsal suckers, and rely on the host’s movement to travel long distances and feed. Although the remora fish itself has poor swimming ability, it can migrate and navigate between different marine areas due to its unique adhesion ability. Inspired by this, combining the adhesion mechanism with the fish-like swimming method, we have developed an adhesive bionic robotic remora. By utilizing the hitch-hiking behavior, the robotic fish can reduce energy consumption, potentially greatly improving its endurance. Additionally, the adhesive function has potential applications in multi-robot systems and covert reconnaissance tasks for specific targets.
Based on the above background, this project aims to develop a novel adhesive bionic robotic remora and achieve fully autonomous adhesion tasks. In pursuit of this goal, the project focuses on the following aspects: system design and modeling of the adhesive bionic robotic remora, underwater visual localization based on artificial markers and refraction correction, and autonomous adhesion control for static and moving targets. The specific framework is shown in the figure below.
2 Innovative Achievements 2.1 System Design and Modeling of Adhesive Bionic Robotic Remora The world’s first prototype of an adhesive biomimetic robotic remora was developed, including the design of the electromechanical system, low-level motion control software, and upper-level graphical user interface. Specifically, the robotic fish includes four main systems: the motion system, perception system, adhesion system, and communication system. Innovations were made in each of these systems:
Motion System: Designed omnidirectional pectoral fin joints and a compact buoyancy adjustment device, endowing the robotic fish with exceptional 3D mobility. Perception System: Developed a binocular perception system with an active gimbal structure, enabling large-scale underwater environmental perception. Adhesion System: Optimized the hardness and shape of the biomimetic sucker and designed a system with both perception and active adhesion capabilities. Communication System: Designed and implemented the RFLink communication protocol for underwater multi-robot communication, ensuring accurate and efficient data transmission. The 3D dynamic model of the robotic fish was completed, along with a visualized 3D motion simulation environment. Specifically, the following work was completed:
Dynamic Modeling: Using the Newton-Euler method, the dynamic models of the robotic fish body and buoyancy adjustment device were created. A quasi-steady lift-drag model and the Lighthill’s large amplitude elongated body theory, were used to analyze the forces on static and oscillating fins, ultimately resulting in a complete 3D motion model. 3D Motion Simulation: A visualized 3D motion simulation environment was developed based on the derived kinematic model. Actual motion data from the robotic fish was used for parameter identification. The developed simulation environment exhibits high fidelity and can even reproduce advanced maneuvers such as spiral descents, forward flips, and horizontal rolls. 2.2 Underwater Visual Localization Based on Artificial Markers and Refraction Correction Designed and implemented an underwater stereo visual-inertial localization algorithm based on ArUco markers. This algorithm provides accurate positioning information for the robotic fish’s autonomous adhesion tasks, with the following features:
The system analyzed the refraction model and imaging characteristics of the flat waterproof cover. The position and orientation estimation method for ArUco markers was re-derived and designed for taking into account the refraction distortion effects. Using an error-state Kalman filter framework, IMU raw data and ArUco marker pose estimation results were fused to obtain more stable and precise position estimates for the robotic fish. Designed and implemented an underwater fish-eye visual localization method based on LED markers. This algorithm also provides precise positioning information for the robotic fish’s autonomous adhesion tasks, with the following features:
An image recognition and pattern matching algorithm was developed for LED markers, enabling rapid and stable detection of markers and the determination of matching relationships for feature points. The system analyzed the refraction model and imaging characteristics of spherical waterproof covers and used DLT and LM algorithms to optimize the pose estimation of LED markers. 2.3 Autonomous Adhesion Control for Floating Targets Designed an autonomous adhesion control strategy based on a finite-state machine, describing the process of autonomous adhesion to floating targets as six states: cruising search, target approach, pose adjustment, adhesion control, adhesion maintenance, and detachment control. Motion controllers for each sub-state were designed and implemented in a physical robotic fish prototype. Related results were published in IEEE Transactions on Mechatronics.
Proposed a planar position control algorithm based on tail fin driving, establishing a planar averaged dynamic model for tail-driven robotic fish. A orientation-velocity control objective with velocity constraints was designed, and a nonlinear model predictive control approach was used to solve for the final control inputs. The proposed algorithm was validated in a simulation environment, demonstrating its ability to effectively overcome the challenges posed by the robotic fish’s underactuated characteristics and achieve stable and precise position control. The related results were published in Nonlinear Dynamics.
Proposed a planar pose control algorithm based on pectoral fin mode switching. The control process was divided into two phases: path tracking and fine adjustment. During the path tracking phase, virtual paths and mode-holding regions were introduced to enable fast convergence of lateral position and heading errors. In the fine adjustment phase, a hyperbolic tangent function was used to adjust the amplitude of pectoral fin oscillation, ensuring convergence of the longitudinal position error. Proposed a depth control algorithm based on a nonlinear disturbance observer. A vertical motion model based on the buoyancy adjustment device was established, and feedback linearization and disturbance observation techniques were used to design a depth controller.
2.4 Autonomous Adhesion Control for Moving Targets Designed an autonomous adhesion control strategy based on a finite-state machine, describing the process of autonomous adhesion to moving targets as five states: cruising search, target tracking, synchronized adhesion, adhesion maintenance, and detachment control. Motion controllers for each sub-state were designed and implemented in a physical robotic fish prototype. Related results were published in IEEE Transactions on Industrial Electronics. Proposed a multi-modal motion-based planar state synchronization control algorithm. Given the underactuated characteristics of the robotic fish, the control was decomposed into lateral and longitudinal control. Lateral control employed line-of-sight navigation to track the heading of the moving target with the tail fin, while longitudinal control simplified the system to a second-order integrator model with external disturbances. A sliding mode controller was designed for controlling the pectoral fins, ensuring that the position and velocity of the robotic fish converged to the moving target. 3 Videos 3.1 Nonlinear Model Predictive Position Control 3.2 Underwater Stereo Visual-Inertial Localization 3.3 Autonomous hitch-hiking behaviors for stationary hosts 3.4 Autonomous hitch-hiking behaviors for moving hosts 4 Publications Pengfei Zhang, Zhengxing Wu, Yan Meng, Min Tan, Junzhi Yu. Nonlinear Model Predictive Position Control for a Tail-Actuated Robotic Fish. IEEE Transactions on Mechatronics. 2020.
Pengfei Zhang, Zhengxing Wu, Jian Wang, Shihan Kong, Min Tan, Junzhi Yu. An Open-Source, Fiducial-Based, Underwater Stereo Visual-Inertial Localization Method with Refraction Correction. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems. 2021
Pengfei Zhang, Zhengxing Wu, Yan Meng, Huijie Dong, Min Tan, Junzhi Yu. Development and Control of a Bioinspired Robotic Remora for Hitchhiking. IEEE Transactions on Mechatronics. 2021.
Pengfei Zhang, Zhengxing Wu, Di Chen, Min Tan, Junzhi Yu (2023). Autonomous Dynamic Hitch-Hiking Control of a Bionic Robotic Remora. IEEE Transactions on Industrial Electronics. 2023.</a></p>
      </div>
      <div class="flex-none">
        <div class="mt-3 flex items-center space-x-3 text-gray-500 dark:text-gray-400 cursor-default">
          
          
          <time class="truncate text-sm" datetime="2022-07-01">Jul 1, 2022</time>
        </div>
      </div>

    </div>
  </div>
</div>

  
    









<div class="group cursor-pointer">

  
  
  
    
  
  
  <div class="overflow-hidden rounded-md bg-gray-100 transition-all hover:scale-105 dark:bg-gray-800">

    <a
      class="relative block aspect-video"
      href="/project/attitude_stability/" >

      <img alt="Robotic Fish with Reaction Wheel"
           class="object-contain transition-all"
           data-nimg="fill"
           decoding="async"
           fetchpriority="high" height="388" loading="lazy" src="/project/attitude_stability/featured_hu1395028611759621087.webp"
           style="position: absolute; height: 100%; width: 100%; inset: 0px; color: transparent;"
           width="960"></a>
  </div>
  
  <div class="">
    <div class="">
      <div class="flex gap-3">
        
        <a href="/tags/robotic/"><span
          class="inline-block text-xs font-medium tracking-wider uppercase mt-5 text-primary-700 dark:text-primary-300">Robotic</span></a>
        
      </div>
      
      <h2 class="text-lg font-semibold leading-snug tracking-tight mt-2 dark:text-white"><a
        href="/project/attitude_stability/" ><span
        class="bg-gradient-to-r from-primary-200 to-primary-100 bg-[length:0px_10px] bg-left-bottom bg-no-repeat transition-[background-size] duration-500 hover:bg-[length:100%_3px] group-hover:bg-[length:100%_10px] dark:from-primary-800 dark:to-primary-900">Robotic Fish with Reaction Wheel
          </span></a>
      </h2>
      
      <div class="grow"><p class="mt-2 line-clamp-3 text-sm text-gray-500 dark:text-gray-400"><a
        href="/project/attitude_stability/" >
        1 Background The propulsion mechanism of the bionic robotic fish, which generates thrust through the reciprocal swinging motion of the fish body, inevitably causes instability in the robot’s attitude. Among these, the periodic oscillation of the yaw angle and roll angle is particularly severe. The oscillation in attitude leads to fluctuations in the sensor data of the robotic fish, which can significantly degrade the quality of image data (motion blur), creating major challenges for the robot environmental perception. Based on this background, this project focuses on two areas of research: fish body attitude stabilization technology and sensor attitude stabilization technology.</a></p>
      </div>
      <div class="flex-none">
        <div class="mt-3 flex items-center space-x-3 text-gray-500 dark:text-gray-400 cursor-default">
          
          
          <time class="truncate text-sm" datetime="2020-07-01">Jul 1, 2020</time>
        </div>
      </div>

    </div>
  </div>
</div>

  

    </div>
</div>


</div>






  

  
</section>

  


    </div>
    <div class="page-footer">
      <footer class="container mx-auto flex flex-col justify-items-center text-sm leading-6 mt-24 mb-4 text-slate-700 dark:text-slate-200">

  












  
  
  
  
  














  
  
  

  
  
    
  
  
    
  

  

  
  <p class="powered-by text-center">
    © 2024 Me. This work is licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank">CC BY NC ND 4.0</a>
  </p>
  

  <p class="powered-by footer-license-icons">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank" aria-label="Creative Commons">
      <i class="fab fa-creative-commons fa-2x" aria-hidden="true"></i>
      <i class="fab fa-creative-commons-by fa-2x" aria-hidden="true"></i>
      
        <i class="fab fa-creative-commons-nc fa-2x" aria-hidden="true"></i>
      
      
        <i class="fab fa-creative-commons-nd fa-2x" aria-hidden="true"></i>
      
    </a>
  </p>





  <p class="powered-by text-center">
    
    
    
      
      
      
      
      
      
      Published with <a href="https://hugoblox.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Hugo Blox Builder</a> — the free, <a href="https://github.com/HugoBlox/hugo-blox-builder" target="_blank" rel="noopener">open source</a> website builder that empowers creators.
    
  </p>

</footer>

    </div>

    
    











  </body>
</html>
